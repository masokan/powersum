package com.github.masokan.powersum;

import java.math.BigInteger;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.List;

public class StirlingPowerSum implements PowerSum {
  public StirlingPowerSum() {
  }

  @Override
  public void printSumFormula(long power, PrintStream out) {
    if (power < 0) {
      return;
    }

    List<BigInteger> coeffs = getCoefficients(power, power + 1);
    boolean firstTime = true;
    for (int t = 0; t < coeffs.size(); t++) {
      BigInteger coeff = coeffs.get(t);
      if (coeff.signum() != 0) {
        if (firstTime) {
          out.print("   ");
          firstTime = false;
        } else {
          out.print(" + ");
        }
        if (coeff.compareTo(BigInteger.ONE) == 1) {
          // Coefficient is greater than 1
          out.print("" + coeff);
        }
        printFactors(t, out);
        if (t > 0) {
          out.print("/" + (t + 1));
        }
      }
    }
    out.println();
  }

  @Override
  public BigInteger computeSumWithTimeStat(long power, long n, long[] stat) {
    long before;
    long after;
    BigInteger sum = BigInteger.ZERO;

    if (power < 0 || n < 0) {
      stat[0] = 0;
      stat[1] = 0;
      return sum;
    }

    before = PowerSum.getThreadCpuTime();
    List<BigInteger> coeffs = getCoefficients(power, n + 1);
    after = PowerSum.getThreadCpuTime();
    stat[0] = after - before;
    before = PowerSum.getThreadCpuTime();
    BigInteger fallingFactorial = BigInteger.valueOf(n + 1);
    // When n < power, we need to compute only n + 1 terms
    long numTermsToCompute = Math.min((long)coeffs.size(), n + 1);
    for (long t = 0; t < numTermsToCompute; t++) {
      // We know that the following division is exact and we do this first
      // before the multiplication to avoid generating a large intermediate
      // value
      BigInteger factor = fallingFactorial.divide(BigInteger.valueOf(t + 1));
      sum = sum.add(coeffs.get((int)t).multiply(factor));
      BigInteger multiplier = BigInteger.valueOf(n - t);
      fallingFactorial = fallingFactorial.multiply(multiplier);
    }
    after = PowerSum.getThreadCpuTime();
    stat[1] = after - before;
    return sum;
  }

  @Override
  public List<RationalNumber> getCoefficients(long power) {
    List<BigInteger> coeffs = getCoefficients(power, power + 1);
    return PowerSum.toRationalNumbers(coeffs);
  }

  /**
   * The coefficients are Stirling numbers of second kind which are defined as
   * below:
   * S(0, 0) = 1
   * S(m, 0) = 0 for all m > 0
   * S(m, j) = 0 for all j > m
   * S(m, j) = S(m-1, j-1) + j*S(m-1, j)
   * m is the power of the series (m >= 0)
   * j is the index of the term in the sum formula (j >= 0)
   *
   * List of coefficients (Stirling numbers of second kind) generated by this
   * method for powers up to 10 is shown below for better understanding of the
   * code.
   *
   * ------------------------------------------------------------------------
   *  Power                          Coefficients
   * ------------------------------------------------------------------------
   *    m  m,0  m,1  m,2   m,3   m,4    m,5    m,6    m,7  m,8  m,9  m,10
   * ------------------------------------------------------------------------
   *    0    1
   *    1    0   1
   *    2    0   1    1
   *    3    0   1    3     1
   *    4    0   1    7     6      1
   *    5    0   1   15    25     10      1
   *    6    0   1   31    90     65     15      1
   *    7    0   1   63   301    350    140     21     1
   *    8    0   1  127   966   1701   1050    266    28     1
   *    9    0   1  255  3025   7770   6951   2646   462    36    1
   *   10    0   1  511  9330  34105  42525  22827  5880   750   45    1
   */
  private List<BigInteger> getCoefficients(long power,
                                           long maxNumCoefficients) {
    ArrayList<BigInteger> coeffs = new ArrayList<>();
    if (power < 0) {
      return coeffs;
    }

    if (power > 0) {
      maxNumCoefficients--;
      for (long i = 0; i <= power; i++) {
        coeffs.add(BigInteger.ZERO);
      }
      // Anchors to hold values from previous iteration
      BigInteger Smj = BigInteger.ZERO;
      BigInteger Sm_1j_1 = BigInteger.ONE; // S(0, 0)
      for (long currentPower = 1; currentPower <= power; currentPower++) {
        long termMax = Math.min(currentPower, maxNumCoefficients);
        for(long term = 1; term <= termMax; term++) {
          BigInteger Sm_1j = coeffs.get((int)(term));
          Smj = Sm_1j.multiply(BigInteger.valueOf(term));
          Smj = Smj.add(Sm_1j_1);
          Sm_1j_1 = coeffs.get((int)(term));
          coeffs.set((int)(term), Smj);
        }
        Sm_1j_1 = coeffs.get(0);
      }
    } else {
      coeffs.add(BigInteger.ONE);
    }
    return coeffs;
  }

  private void printFactors(int term, PrintStream out) {
    for(int i = 0; i <= term; i++) {
      switch(i) {
        case 0:
          out.print("(n + 1)");
          break;
        case 1:
          out.print("n");
          break;
        default:
          out.print("(n - " + (i - 1) + ")");
          break;
      }
    }
  }

}
